@startuml newContractArch

title Proposed New Contracts Architecture

namespace BetInterfaces {
    interface Token {
        address: Address
        betId: string
        wager: FUSDVault
    }

    interface Result {
        betId: string
    }

    interface Bet {
        placeBet(token: &Token)
        resolveBet(token: &Result): &PayoutInterfaces::ResultsToken
    }

    interface TokenMinter {
        mintToken(address: Address): &Token
    }
}

namespace YesNoBetContract {
    class Wager {
        address: Address
        bet: bool
        wager: UFi64
    }

    class UserToken {
        address: Address
        betId: string
        bet: bool
        wager: FUSDVault
    }

    class ResultToken {
        betId: string
        result: bool
    }

    class ResultTokenMinter {
        betId: string
        mint(result: bool): &BetInterface::Result
    }

    class State {
        isResolved: bool
        wagers: Wager[]
    }

    class BetResource {
        - betResultsTokenMinter: @WinLossPayoutContract::BetResultsTokenMinter
        + state: State
        
        placeBet(token: &BetInterfaces::Token)
        resolveBet(token: &BetInterfaces::Result): &PayoutInterfaces::ResultsToken
        mintToken(address: Address): &BetInterfaces::Token
        createResultTokenMinter(): @ResultTokenMinter
    }
}

namespace ResolverInterfaces {
    interface Token {
        betId: string
        address: Address
    }

    interface Resolver {
        vote(token: &Token)
        resolve(): &BetInterfaces::Result?
    }

    interface TokenMinter {
        mintToken(address: Address): &Token
    }
}

namespace YesNoResolverContract {
    class UserToken {
        betId: string
        address: Address
        vote: bool?
    }

    class State {
        isResolved: bool
        votes: Vote[]
    }

    class Vote {
        address: Address
        vote: bool?
    }

    class MajorityResolver {
        - resultTokenMinter: @YesNoBetContract::ResultTokenMinter
        + state: State
        
        vote(token: &Token)
        resolve(): &BetInterfaces::Result?
        mintToken(address: Address): &ResolverInterfaces::Token
    }
}

namespace PayoutInterfaces {
    interface Token {
        betId: string
        address: Address
    }

    interface TokenMinter {
        mintToken(address: Address): &Token
    }

    interface ResultsToken {
        betId: string
    }

    interface Payout {
        +balance: UFix64
        deposit(from: @Vault)
        resolve(token: &ResultsToken)
        withdraw(token: &Token): @Vault
        getState(): PayoutState
    }

    class State {
        isResolved: bool
        payouts: UserPayout[]
    }

    class UserPayout {
        balance: UFix64
        hasRetrieved: bool
    }
}

namespace WinLosePayoutContract {
    class Bettor {
        address: Address
        wager: UFix64
    }

    class BetResults {
        betId: string
        winners: Bettor[]
        losers: Bettor[]
    }

    class BetResultsTokenMinter {
        betId: string
        mint(winners: Bettor[], losers: Bettor[]): @BetResults
    }

    class UserToken {
        betId: string
        address: Address
    }

    class PayoutResource {
        +balance: UFix64
        deposit(from: @Vault)
        resolve(results: &PayoutInterfaces::ResultsToken)
        withdraw(token: &PayoutInterfaces::Token): @Vault
        getState(): PayoutInterfaces::State
        mintToken(address: Address): &PayoutInterfaces::Token
        createBetTokenMinter(): @BetResultsTokenMinter
    }
}


PayoutInterfaces.Payout --> PayoutInterfaces.Token
PayoutInterfaces.Payout --> PayoutInterfaces.ResultsToken
PayoutInterfaces.TokenMinter --> PayoutInterfaces.Token
PayoutInterfaces.Payout --> PayoutInterfaces.State
PayoutInterfaces.State --* PayoutInterfaces.UserPayout
WinLosePayoutContract.PayoutResource --|> PayoutInterfaces.Payout
WinLosePayoutContract.PayoutResource --|> PayoutInterfaces.TokenMinter
WinLosePayoutContract.PayoutResource --> WinLosePayoutContract.BetResultsTokenMinter
WinLosePayoutContract.BetResultsTokenMinter --> WinLosePayoutContract.BetResults
WinLosePayoutContract.BetResults --* WinLosePayoutContract.Bettor
WinLosePayoutContract.BetResults --|> PayoutInterfaces.ResultsToken
WinLosePayoutContract.UserToken --|> PayoutInterfaces.Token
WinLosePayoutContract.PayoutResource --> WinLosePayoutContract.UserToken

BetInterfaces.Bet --> BetInterfaces.Token
BetInterfaces.Bet --> BetInterfaces.Result
BetInterfaces.Bet --> PayoutInterfaces.ResultsToken
YesNoBetContract.BetResource --|> BetInterfaces.Bet
YesNoBetContract.BetResource --|> BetInterfaces.TokenMinter
YesNoBetContract.BetResource --* YesNoBetContract.State
YesNoBetContract.State --* YesNoBetContract.Wager
YesNoBetContract.BetResource --> YesNoBetContract.UserToken
YesNoBetContract.BetResource --> YesNoBetContract.ResultTokenMinter
YesNoBetContract.ResultTokenMinter --> YesNoBetContract.ResultToken
YesNoBetContract.BetResource --* WinLosePayoutContract.BetResultsTokenMinter
YesNoBetContract.UserToken --|> BetInterfaces.Token
YesNoBetContract.ResultToken --|> BetInterfaces.Result

ResolverInterfaces.Resolver --> ResolverInterfaces.Token
ResolverInterfaces.Resolver --> BetInterfaces.Result
ResolverInterfaces.TokenMinter --> ResolverInterfaces.Token
YesNoResolverContract.MajorityResolver --|> ResolverInterfaces.Resolver
YesNoResolverContract.MajorityResolver --|> ResolverInterfaces.TokenMinter
YesNoResolverContract.MajorityResolver --> YesNoResolverContract.UserToken
YesNoResolverContract.UserToken --|> ResolverInterfaces.Token
YesNoResolverContract.MajorityResolver --* YesNoBetContract.ResultTokenMinter
YesNoResolverContract.MajorityResolver --* YesNoResolverContract.State
YesNoResolverContract.State --* YesNoResolverContract.Vote
@enduml
