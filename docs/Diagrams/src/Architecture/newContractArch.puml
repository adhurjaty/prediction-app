@startuml newContractArch

title Proposed New Contracts Architecture

namespace Bets {
    namespace BetInterfaces {
        interface Wager {
            address: Address
            amount: UFix64
        }

        interface State {
            isResolved: bool
            wagers: Wager[]
        }

        interface Token {
            address: Address
            betId: string
            wager: FUSDVault
        }

        interface Bet {
            + state: State
            placeWager(token: @Token): TokenResponse
            castVote(token: @ResolverInterfaces::Token)
            resolve(): bool
            retrievePayout(token: @PayoutInterfaces::Token)
        }

        interface TokenMinter {
            mintToken(address: Address): &Token
        }

        class TokenResponse {
            resolverToken(): @ResolverInterfaces::Token
            payoutToken(): @PayoutInterfaces::Token
        }
    }

    namespace YesNoBetContract {
        class Wager {
            address: Address
            bet: bool
            wager: UFi64
        }

        class UserToken {
            address: Address
            betId: string
            bet: bool
            wager: FUSDVault
        }

        class State {
            isResolved: bool
            wagers: Wager[]
        }

        class BetResource {
            - resolver: &ResolverInterfaces::Resolver
            - payout: &PayoutInterfaces::Payout
            + state: State
            
            placeWager(token: @Token): TokenResponse
            castVote(token: @ResolverInterfaces::Token)
            resolve(): bool
            retrievePayout(token: @PayoutInterfaces::Token)
            mintToken(address: Address): &BetInterfaces::Token
        }
    }
}

namespace Resolvers {
    namespace ResolverInterfaces {
        interface Token {
            betId: string
            address: Address
        }

        interface Result {
            betId: string
        }

        interface Resolver {
            mintToken(token: @DelphaiInterfaces::Token): &Token
            vote(token: @Token)
            resolve(): Result?
        }
    }

    namespace YesNoResolverContract {
        class UserToken {
            betId: string
            address: Address
            vote: bool?
        }

        class State {
            isResolved: bool
            votes: Vote[]
        }

        class Result {
            betId: string
            result: bool
        }

        class Vote {
            address: Address
            vote: bool?
        }

        class MajorityResolver {
            + state: State
            
            mintToken(token: @DelphaiInterfaces::Token): @ResolverInterfaces::Token
            vote(token: @Token)
            resolve(): Result?
        }
    }
}

namespace Payouts {
    namespace PayoutInterfaces {
        interface Token {
            betId: string
            address: Address
        }

        interface BetResults {
            betId: string
        }

        interface Payout {
            +balance: UFix64
            mintToken(token: @DelphaiInterfaces::Token): @Token
            deposit(from: @Vault)
            resolve(results: BetResults)
            withdraw(token: &Token): @Vault
        }

        class State {
            isResolved: bool
            payouts: UserPayout[]
        }

        class UserPayout {
            balance: UFix64
            hasRetrieved: bool
        }
    }

    namespace WinLosePayoutContract {
        class Bettor {
            address: Address
            wager: UFix64
        }

        class BetResults {
            betId: string
            winners: Bettor[]
            losers: Bettor[]
        }

        class UserToken {
            betId: string
            address: Address
        }

        class PayoutResource {
            +balance: UFix64
            mintToken(token: @DelphaiInterfaces::Token): @PayoutInterfaces::Token
            deposit(from: @Vault)
            resolve(results: PayoutInterfaces::BetResults)
            withdraw(token: &PayoutInterfaces::Token): @Vault
        }
    }
}

namespace DelphaiInterfaces {
    interface Token {
        address: Address
        betId: string
    }
}

Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.Token
Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.BetResults
Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.State
Payouts.PayoutInterfaces.Payout --> DelphaiInterfaces.Token
Payouts.PayoutInterfaces.State --* Payouts.PayoutInterfaces.UserPayout
Payouts.WinLosePayoutContract.PayoutResource --|> Payouts.PayoutInterfaces.Payout
Payouts.WinLosePayoutContract.PayoutResource --> Payouts.WinLosePayoutContract.BetResults
Payouts.WinLosePayoutContract.BetResults --* Payouts.WinLosePayoutContract.Bettor
Payouts.WinLosePayoutContract.BetResults --|> Payouts.PayoutInterfaces.BetResults
Payouts.WinLosePayoutContract.UserToken --|> Payouts.PayoutInterfaces.Token
Payouts.WinLosePayoutContract.PayoutResource --> Payouts.WinLosePayoutContract.UserToken

Bets.BetInterfaces.Bet --> Bets.BetInterfaces.Token
Bets.BetInterfaces.Bet --> Payouts.PayoutInterfaces.Token
Bets.BetInterfaces.Bet --> Resolvers.ResolverInterfaces.Token
Bets.BetInterfaces.Bet --> Bets.BetInterfaces.TokenResponse
Bets.BetInterfaces.Bet --* Bets.BetInterfaces.State
Bets.BetInterfaces.State --* Bets.BetInterfaces.Wager
Bets.YesNoBetContract.BetResource --|> Bets.BetInterfaces.Bet
Bets.YesNoBetContract.BetResource --|> Bets.BetInterfaces.TokenMinter
Bets.YesNoBetContract.BetResource --* Bets.YesNoBetContract.State
Bets.YesNoBetContract.State --* Bets.YesNoBetContract.Wager
Bets.YesNoBetContract.BetResource --> Bets.YesNoBetContract.UserToken
Bets.YesNoBetContract.UserToken --|> Bets.BetInterfaces.Token
Bets.YesNoBetContract.UserToken --|> DelphaiInterfaces.Token
Bets.YesNoBetContract.BetResource --* Payouts.PayoutInterfaces.Payout
Bets.YesNoBetContract.BetResource --* Resolvers.ResolverInterfaces.Resolver
Bets.YesNoBetContract.State --|> Bets.BetInterfaces.State

Resolvers.ResolverInterfaces.Resolver --> Resolvers.ResolverInterfaces.Token
Resolvers.ResolverInterfaces.Resolver --> Resolvers.ResolverInterfaces.Result
Resolvers.ResolverInterfaces.Resolver --> DelphaiInterfaces.Token
Resolvers.YesNoResolverContract.MajorityResolver --|> Resolvers.ResolverInterfaces.Resolver
Resolvers.YesNoResolverContract.MajorityResolver --> Resolvers.YesNoResolverContract.UserToken
Resolvers.YesNoResolverContract.UserToken --|> Resolvers.ResolverInterfaces.Token
Resolvers.YesNoResolverContract.UserToken --|> DelphaiInterfaces.Token
Resolvers.YesNoResolverContract.MajorityResolver --* Resolvers.YesNoResolverContract.State
Resolvers.YesNoResolverContract.State --* Resolvers.YesNoResolverContract.Vote
Resolvers.YesNoResolverContract.MajorityResolver --> Resolvers.YesNoResolverContract.Result
Resolvers.YesNoResolverContract.Result --|> Resolvers.ResolverInterfaces.Result
@enduml
