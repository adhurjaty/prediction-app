@startuml newContractArch

title Proposed New Contracts Architecture

namespace Bets {
    namespace BetInterfaces {
        interface Token {
            address: Address
            betId: string
            wager: FUSDVault
        }

        interface Result {
            betId: string
        }

        interface Bet {
            placeBet(token: &Token)
            resolveBet(token: &Result): &PayoutInterfaces::ResultsToken
        }

        interface TokenMinter {
            mintToken(address: Address): &Token
        }
    }

    namespace YesNoBetContract {
        class Wager {
            address: Address
            bet: bool
            wager: UFi64
        }

        class UserToken {
            address: Address
            betId: string
            bet: bool
            wager: FUSDVault
        }

        class ResultToken {
            betId: string
            result: bool
        }

        class ResultTokenMinter {
            betId: string
            mint(result: bool): &BetInterface::Result
        }

        class State {
            isResolved: bool
            wagers: Wager[]
        }

        class BetResource {
            - betResultsTokenMinter: @WinLossPayoutContract::BetResultsTokenMinter
            + state: State
            
            placeBet(token: &BetInterfaces::Token)
            resolveBet(token: &BetInterfaces::Result): &PayoutInterfaces::ResultsToken
            mintToken(address: Address): &BetInterfaces::Token
            createResultTokenMinter(): @ResultTokenMinter
        }
    }
}

namespace Resolvers {
    namespace ResolverInterfaces {
        interface Token {
            betId: string
            address: Address
        }

        interface Resolver {
            vote(token: &Token)
            resolve(): &BetInterfaces::Result?
        }

        interface TokenMinter {
            mintToken(address: Address): &Token
        }
    }

    namespace YesNoResolverContract {
        class UserToken {
            betId: string
            address: Address
            vote: bool?
        }

        class State {
            isResolved: bool
            votes: Vote[]
        }

        class Vote {
            address: Address
            vote: bool?
        }

        class MajorityResolver {
            - resultTokenMinter: @YesNoBetContract::ResultTokenMinter
            + state: State
            
            vote(token: &Token)
            resolve(): &BetInterfaces::Result?
            mintToken(address: Address): &ResolverInterfaces::Token
        }
    }
}

namespace Payouts {
    namespace PayoutInterfaces {
        interface Token {
            betId: string
            address: Address
        }

        interface TokenMinter {
            mintToken(address: Address): &Token
        }

        interface ResultsToken {
            betId: string
        }

        interface Payout {
            +balance: UFix64
            deposit(from: @Vault)
            resolve(token: &ResultsToken)
            withdraw(token: &Token): @Vault
            getState(): PayoutState
        }

        class State {
            isResolved: bool
            payouts: UserPayout[]
        }

        class UserPayout {
            balance: UFix64
            hasRetrieved: bool
        }
    }

    namespace WinLosePayoutContract {
        class Bettor {
            address: Address
            wager: UFix64
        }

        class BetResults {
            betId: string
            winners: Bettor[]
            losers: Bettor[]
        }

        class BetResultsTokenMinter {
            betId: string
            mint(winners: Bettor[], losers: Bettor[]): @BetResults
        }

        class UserToken {
            betId: string
            address: Address
        }

        class PayoutResource {
            +balance: UFix64
            deposit(from: @Vault)
            resolve(results: &PayoutInterfaces::ResultsToken)
            withdraw(token: &PayoutInterfaces::Token): @Vault
            getState(): PayoutInterfaces::State
            mintToken(address: Address): &PayoutInterfaces::Token
            createBetTokenMinter(): @BetResultsTokenMinter
        }
    }
}

Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.Token
Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.ResultsToken
Payouts.PayoutInterfaces.TokenMinter --> Payouts.PayoutInterfaces.Token
Payouts.PayoutInterfaces.Payout --> Payouts.PayoutInterfaces.State
Payouts.PayoutInterfaces.State --* Payouts.PayoutInterfaces.UserPayout
Payouts.WinLosePayoutContract.PayoutResource --|> Payouts.PayoutInterfaces.Payout
Payouts.WinLosePayoutContract.PayoutResource --|> Payouts.PayoutInterfaces.TokenMinter
Payouts.WinLosePayoutContract.PayoutResource --> Payouts.WinLosePayoutContract.BetResultsTokenMinter
Payouts.WinLosePayoutContract.BetResultsTokenMinter --> Payouts.WinLosePayoutContract.BetResults
Payouts.WinLosePayoutContract.BetResults --* Payouts.WinLosePayoutContract.Bettor
Payouts.WinLosePayoutContract.BetResults --|> Payouts.PayoutInterfaces.ResultsToken
Payouts.WinLosePayoutContract.UserToken --|> Payouts.PayoutInterfaces.Token
Payouts.WinLosePayoutContract.PayoutResource --> Payouts.WinLosePayoutContract.UserToken

Bets.BetInterfaces.Bet --> Bets.BetInterfaces.Token
Bets.BetInterfaces.Bet --> Bets.BetInterfaces.Result
Bets.BetInterfaces.Bet --> Payouts.PayoutInterfaces.ResultsToken
Bets.YesNoBetContract.BetResource --|> Bets.BetInterfaces.Bet
Bets.YesNoBetContract.BetResource --|> Bets.BetInterfaces.TokenMinter
Bets.YesNoBetContract.BetResource --* Bets.YesNoBetContract.State
Bets.YesNoBetContract.State --* Bets.YesNoBetContract.Wager
Bets.YesNoBetContract.BetResource --> Bets.YesNoBetContract.UserToken
Bets.YesNoBetContract.BetResource --> Bets.YesNoBetContract.ResultTokenMinter
Bets.YesNoBetContract.ResultTokenMinter --> Bets.YesNoBetContract.ResultToken
Bets.YesNoBetContract.BetResource --* Payouts.WinLosePayoutContract.BetResultsTokenMinter
Bets.YesNoBetContract.UserToken --|> Bets.BetInterfaces.Token
Bets.YesNoBetContract.ResultToken --|> Bets.BetInterfaces.Result

Resolvers.ResolverInterfaces.Resolver --> Resolvers.ResolverInterfaces.Token
Resolvers.ResolverInterfaces.Resolver --> Bets.BetInterfaces.Result
Resolvers.ResolverInterfaces.TokenMinter --> Resolvers.ResolverInterfaces.Token
Resolvers.YesNoResolverContract.MajorityResolver --|> Resolvers.ResolverInterfaces.Resolver
Resolvers.YesNoResolverContract.MajorityResolver --|> Resolvers.ResolverInterfaces.TokenMinter
Resolvers.YesNoResolverContract.MajorityResolver --> Resolvers.YesNoResolverContract.UserToken
Resolvers.YesNoResolverContract.UserToken --|> Resolvers.ResolverInterfaces.Token
Resolvers.YesNoResolverContract.MajorityResolver --* Bets.YesNoBetContract.ResultTokenMinter
Resolvers.YesNoResolverContract.MajorityResolver --* Resolvers.YesNoResolverContract.State
Resolvers.YesNoResolverContract.State --* Resolvers.YesNoResolverContract.Vote
@enduml
