@startuml

title Contracts Inheritance

abstract class MembersOnly {
    members : mapping(address => bool)
    numMembers : uint

    isMember(): modifier
    addMember(address) isMember: void
    checkMembership(): bool
    pay(person: address, amount: wei): void
}

abstract class Managed {
    commisioner: address
    isCommissioner(): modifier
    setCommissioner(address): void
    addMember(address) isCommissioner: void
}

abstract class Resolver {
    timeResolved : date?
    betClosingTime: date
    {abstract} getWinners(): address[]
}

abstract class YesNoResolver {
    result: bool?
    {abstract} setResolved(bool): void
}

abstract class OracleYesNoResolver {

}

abstract class VoteYesNoResolver {
    votes: mapping(address => bool)
    numYeses: uint
    numNos: uint

    hasntVoted(): modifier
    vote(bool) isMember hasntVoted: void
}

class MajorityVoteYesNoResolver {
    {override} setResolved(bool): void
}

class UnanimousVoteYesNoResolver {
    {override} setResolved(bool): void
}

abstract class ScalarResolver {
    result: int?
}

abstract class VoteScalarResolver {
    votes: mapping(address => int)
}

abstract class Bet {
    title: string
    bets: mapping(address => uint)
    closingTime: date
    wager: event
    payMember: event
    pool: wei

    getWager(address): uint
    getMyWager(): uint
    {abstract} getWinners(): address[]
}

class VoteYesNoContract {
    resolverType: VoteTypeEnum
    betType: BetTypeEnum
}

abstract class YesNoBet {
    predictions: mapping(address => bool)
    {virtual} wager(bool): void
    {abstract} pay(bool): void
}

class HubAndSpokeBet {
    hubVote: bool
    hub: address
    {override} wager(bool): void
}

class OracleYesNoContract {
    checkOracle(): bool?
}

class AverageScalarResolver {
    {override} setResolved(int): void
}

class UnanimousScalarResolver {
    {override} setResolved(int): void
}

class PriceIsRightBet {
    {override} setResolved(int): void
}

class ClosestBet {
    {override} setResolved(int): void
}

abstract class ScalarBet {
    predictions: mapping(address => int)
    {virtual} wager(int): void
    {abstract} pay(int): void
}

class VoteScalarBet {
    type: ScalarVoteTypeEnum
    betType: BetTypeEnum
}

interface IBet {
    getWinners(): address[]
}

interface IYesNoBet {
    result: bool?
    wager(bool): void
    getMyWager(): bool
    getWager(address): bool
}

interface IScalarBet {
    result: int?
    wager(int)
    getMyWager(): int
    getWager(address): int
    getResult(): int?
}

interface IVoteYesNoContract {
    vote(bool): void
}

interface IVoteScalarBet {
    vote(int): vote
}

interface IOracleYesNoContract {
    checkOracle(): bool?
}

interface IOracleScalarBet {
    checkOracle(): int?
}

Managed --|> MembersOnly
Resolver --|> Managed
YesNoResolver --|> Resolver
ScalarResolver --|> Resolver
VoteYesNoResolver --|> YesNoResolver
OracleYesNoResolver --|> YesNoResolver
MajorityVoteYesNoResolver --|> VoteYesNoResolver
UnanimousVoteYesNoResolver --|> VoteYesNoResolver
VoteScalarResolver --|> ScalarResolver
Bet --|> Managed

IYesNoBet --|> IBet
IScalarBet --|> IBet

IVoteYesNoContract --|> IYesNoBet
IOracleYesNoContract --|> IYesNoBet
IVoteScalarBet --|> IScalarBet
IOracleScalarBet --|> IScalarBet

YesNoBet --|> Bet
HubAndSpokeBet --|> YesNoBet

VoteYesNoContract --|> IVoteYesNoContract
VoteYesNoContract --* MajorityVoteYesNoResolver
VoteYesNoContract --* UnanimousVoteYesNoResolver
VoteYesNoContract --* HubAndSpokeBet

OracleYesNoContract --|> Bet
OracleYesNoContract --|> OracleYesNoResolver
OracleYesNoContract --|> IOracleYesNoContract

PriceIsRightBet --|> ScalarBet
ClosestBet --|> ScalarBet
VoteScalarBet --|> IVoteScalarBet
VoteScalarBet --* PriceIsRightBet
VoteScalarBet --* ClosestBet
AverageScalarResolver --|> VoteScalarResolver
UnanimousScalarResolver --|> VoteScalarResolver
ScalarBet --|> Bet
VoteScalarBet --* AverageScalarResolver
VoteScalarBet --* UnanimousScalarResolver

@enduml